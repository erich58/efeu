\title	Das Kommando make

\sec	Allgemeine Beschreibung

\margin	make
Das Kommando |make| gehört wie der C--Kompiler zum
<"Development System"> des UNIX-Betriebssystem und ist in der
Regel auf allen UNIX--Systemen verfügbar. Es wird im Regelfall
zum Kompilieren einzelner Programme oder Programmpakete
verwendet, eignet sich aber auch sehr gut für Projektarbeiten.

\margin	Rechenregeln
Die Grundlage für das Kommando |make| bilden Rechenregeln
mit den folgenden Komponenten:
*	Das Ziel: Das ist der Name der zu generierenden Datei oder einer
	Teilaufgabe (z.B. Aufräumen).
*	Die Abhängigkeiten: Das ist eine Liste aller Dateien, die das Ergebnis
	bestimmen.
*	Die Befehle: Das ist eine Liste von Befehlsaufrufen, die
	zur Generierung des Ergebnises notwendig sind.

Neben den expliziten Rechenregeln für ein bestimmtes Ziel
gibt es noch interne Rechenregeln für Dateien mit bestimmten Filezusätzen.

Das Kommando |make| führt die Befehle, die zu einem Ziel führen,
immer dann durch, wenn eine der Abhängigkeiten ein neueres Datum
als das Ergebnis selbst aufweist. Fehlende Dateien werden immer
als veraltet betrachtet.
Kommt es bei der Durchführung eines Befehls zu einem Fehler oder
wird die Verarbeitung durch ein Signal abgebrochen,
wird die aktuelle Zieldatei gelöscht.
Die von |make| ausgeführten Befehle werden angezeigt.

Die Abhängigkeiten werden rekursiv geprüft, wenn also eine Datei A von
der Datei B abhängt und diese wiederum von C, so wird vor A zunächst
B auf den letzten Stand gebracht.

\margin	Beschreibungsdatei
Die Rechenregeln werden in einer Beschreibungsdatei
(auch Makefile genannt) zusammengestellt.
Mit der Option |-f| <makefile> wird |make| der Name der
Beschreibungsdatei übergeben. Fehlt die Option, wird nach einer
Datei mit dem Namen |makefile| oder |Makefile| gesucht.

Beim Aufruf von |make| werden die gewünschten Ziele
als Argument übergeben. Wird |make| ohne Argument aufgerufen,
wird das erste Ziel in der Beschreibungsdatei generiert.

Wird |make| mit der Option |-n| aufgerufen, werden die zur
Aktualisierung notwendige Befehle nicht durchgeführt,
sondern nur angezeigt.

Die vorliegende Kurzeinführung in die Funktionsweise von |make|
erhebt keinen Anspruch auf Vollständigkeit. Es wurden bewußt
Aspekte ausgeklammert, die zwar für <"handgeschriebene"> Makefiles
wichtig sind, aber im Kontext generierter Makefiles keine Rolle
spielen.

Weitere Informationen zu |make| können interaktiv mit |man make|
bzw. |info make| abgerufen werden.
Es gibt auch umfangreiche Literatur zur Verwendung von |make|.

\sec	Syntax

Eine Beschreibungsdatei besteht aus Kommentaren, Makrodefinitionen
und Regeln.

\margin	Fortsetzungszeilen
Ein Gegenschrägstrich vor einem Zeilenvorschub hebt diesen auf,
die nachfolgende Zeile gilt dann als Fortsetzung der vorangegangenen
Zeile. Damit können lange Zeilen umgebrochen werden.

<*Achtung:*> Zwischen dem Gegenschrägstrich und den Zeilenvorschub
darf kein Leerzeichen oder Tabulator (unsichtbar im Editor!) stehen.

\margin	Kommentare
Eine Kommentarzeile beginnt mit einem Gittersymbol und endet
beim nächsten Zeilenvorschub.

\margin	Regel
Eine Regel besteht aus einer nichtleren, durch Leerzeichen
getrennte Liste von Zielen, die mit einem einfachen <"|:|"> oder
zweifachen <"|::|"> Doppelpunkt abgeschlossen wird.
Danach folgt optional in der gleichen Zeile eine Liste
von Abhängigkeiten, die wahlweise mit einem Strichpunkt
oder einem Zeilenvorschub abgeschlossen wird.
Den Abschluß der Regel bilden die einzelnen Befehlszeilen,
die entweder durch einen Strichpunkt <"|;|"> oder durch die
Kombination Zeilenvorschub Tabulator getrennt werden.
Sowohl Abhängigkeiten, als auch Befehlszeilen sind optional.

Die erste, nichtleere Zeile, die nicht mit einem Tabulator oder einer
Kommentarkennung beginnt, beendet eine Regel.
Shell Befehlszeilen können mit einem Gegenschrägstrich über mehrere
Zeilen fortgesetzt werden. Die Befehlszeilen werden unverändert der
Shell übergeben. Lediglich der Tabulator und spezielle, weiter unten
angeführte Schalter zu Beginn einer Befehlszeile
werden entfernt.

<*Achtung:*> Tabulatoren können nicht durch Leerzeichen ersetzt
werden!

Die einzelnen Befehlszeilen werden einzeln in der angegebenen
Reihenfolge von der unix-Shell ausgewertet. Im Regelfall
wird jeder von |make| ausgeführte Befehl ausgegeben. Falls
der Rückgabewert der Befehls verschieden von 0 ist, erfolgt ein
Abbruch der Verarbeitung und die aktuellen Ziele werden, falls sie
bereits existieren, gelöscht. Dieses Verhalten kann mit speziellen
Schaltern zu Beginn der Befehlszeile verändert werden

Folgende Schalter können zu Beginn der Befehlszeile in beliebiger
Kombination stehen:
[|-|]
	Der Fehlerkode des Kommandos wird ignoriert.
[|@|]
	Die Befehlszeile wird bei der Ausführung nicht dargestellt.
[|+|]
	Die Befehlszeile wird ausgeführt, auch wenn |make| mit der
	Optionen |-n| aufgerufen wurde.

\margin	Pseudoziele
Im Regelfall handelt es sich bei den Zielen um Dateien, die
bei der Ausführung der angegebenen Befehle generiert werden.
Führt das Ausführen der Befehlszeilen niemals zum Entstehen einer
Datei mit dem Namen des Ziels, wird von einem Pseudoziel gesprochen.
Pseudoziele werden für Aktivitäten wie <"alles generieren"> oder
<"aufräumen"> verwendet. Da nie eine entsprechende Datei generiert
wird, sind Pseudoziele nie am letzten Stand und die entsprechenden
Befehlszeilen, sofern welche existieren, werden immer ausgeführt.

\margin	Einfachregeln
Einfachregeln sind durch einen einfachen Doppelpunkt als Abschluß
der Liste von Zielen gekennzeichnet. Ein Ziel darf bei mehreren
Regeln Verwendung finden, aber nur eine einzige Regel darf
Befehlszeilen enthalten. Die Abhängigkeitslisten aller Regeln werden
zusammengefaßt.
Gibt es keine Abhängigkeiten, werden die Befehlszeilen nur ausgeführt,
wenn die Zieldateien nicht existieren.

\margin	Mehrfachregeln
Mehrfachregeln sind durch einen doppelten Doppelpunkt als Abschluß
der Liste von Zielen gekennzeichnet. Gegenüber von Einfachregeln
dürfen alle Regeln zu einem Ziel Befehlszeilen enthalten.
Es werden nur jene ausgeführt,
deren Abhängigkeitslisten es erforderlich machen.
Eine fehlende
Abhängigkeitsliste führt im Unterschied zu einer Einfachregel
immer zur Ausführung der zugehörigen Befehlszeilen.

Ein einzelnes Ziel kann nicht mit Einfachregeln und mit
Mehrfachregeln gleichzeitig definiert werden.
Mehrfachregeln werden in der Regel
für Pseudoziele verwendet.

\margin	Makros
Eine Makrodefinition hat die Form <"<name>~|=|~<String>">.
Lerrzeichen und Tabulatoren vor und nach dem Zuweisungszeichen <"|=|">
werden ignoriert.
<String> besteht aus allen Zeichen bis zu einer Kommentarkennung oder
einem nicht durch einen Gegenschrägstrich aufgehobenen Zeilenvorschub.
Ein Makro wird durch <"|$(|<name>\[|:|<key>|=|<repl>\]|)|">
abgerufen. Der optionale Zusatz <"|:|<key>=<repl>">
legt eine Ersetzungsregel fest. Dabei wird jedes, nicht überlappende
Vorkommen von <key> durch <repl> ersetzt.

Ein Makro, der nur aus einem Buchstaben besteht, braucht bei der
Expandierung nicht geklammert zu werden.
Somit ist |$A| gleichwertig mit |$(A)|.
Soll ein Dollarsymbol selbst im Beschreibungsfile vorkommen,
sind zwei Dollarsymbole zu verwenden.

Ein nicht definierter Makro liefert einen Leerstring.
Umgebungsvariablen werden standardmäßig in der
Liste der Makros aufgenommen (z.B: |$(HOME)|).

\margin	Interne Makros
Es gibt die folgenden fünf internen Makros:
[|$@|]
	liefert den vollständigen Zielnamen für die aktuelle Regel.
[|$?|]
	liefert die Liste jener Vorraussetzungen für eine explizite Regel,
	die nicht am aktuellen Stand sind.
[|$%|]
	liefert den Namen des Bibliothekeintrags |<file>.o|, wenn
	das Ziel einer Regel ein Archiveintrag
	der Form <|<lib>(<file>.o)|> ist.
	In diesem Fall liefert |$@| den Namen der
	Bibliothek <lib> selbst.
[|$*|]
	liefert den Filenamen der aktuellen Abhängigkeit ohne dem Filezusatz.
	Der Makro wird nur bei internen Regeln ausgewertet.
[|$<|]
	liefert den vollständigen Filenamen der aktuellen Abhängigkeit.
	Der Makro wird nur bei internen Regeln ausgewertet.

Die Makros |$*| und |$<| werden nur bei impliziten Regeln ausgewertet.
Eine implizite Regel beschreibt, wie eine Datei mit einem
bestimmten Filezusatz aus einer Datei gleichen Namen mit anderem
Filezusatz generiert werden kann.

Allen internen Makros kann der Buchstabe |D| oder |F| nachgestellt
werden (z.B: |$(@D)|).
Sie stehen für <"directory part"> bzw. <"file part"> und liefern
entweder den Bibliotheksnamen oder den Filenamen des Makros.

Für die Projektarbeit ist nur der Makro |$@| von Bedeutung.
Er sollte in den Befehlszeilen einer Regel immer anstelle des Zielnamens
eingesetzt werden. Dadurch werden Fehler durch falsche Schreibweisen
vermieden, da der Zielname nur einmal explizit angegeben wird.

\sec	Beispiele

Anhand einer Betriebsauszählung wird die Verwendung
von |make| und der Aufbau der zugehörigen Beschreibungsdatei
aufgezeigt.

\margin	Aufgabenstellung
Aus der Betriebsdatenbank soll die Zahl der Betriebe für jedes Bundesland nach
Betriebsgröße (Durchschnittsbestand) und Wirtschaftsklasse ausgezählt werden.
Die zugehörige Beschreibungsdatei liefert das gewünschte Ergebnis.

---- verbatim
#       Beschreibungsdatei, Version 1

DB=     /db/vz/VZB1999.gz
RNG=	1996
GRP=    grp=ges,bs.gb,dg.wikl
BL=     bland=ges,dg.bland
FLAGS=  -e betr=anz -r $(RNG)

betr.md: $(DB)
        syncnt $(FLAGS) $(DB) $@ $(GRP) $(BL)
----

Steht in der aktuellen Bibliothek eine Datei |Makefile| mit
obigem Inhalt, bewirkt ein Aufruf von |make| das Generieren
der Datei |betr.md|. Die Verwendung von |.md| als Filezusatz
ist reine Konvention.
Ein weiterer Aufruf von |make| liefert eine Meldung der Form:

---- verbatim
make: `betr.md' is up to date.
----

Der genaue Wortlaut ist von der Version von |make| abhängig.

Im folgenden wird eine zweite Auszählung für die Wiener
Gemeindebezirke anstelle der Bundesländer im Beschreibungsfile
eingetragen. Dazu werden an die Bechreibungsdatei die folgenden
Befehlszeilen angehängt:

---- verbatim
BEZ=    bez=ges,dg.wbez

wien.md: $(DB)
        syncnt $(FLAGS) $(DB) $@ $(GRP) $(BEZ)
----

\margin	Pseudoziele
Die Auszählung wird aber nur durchgeführt, wenn |make| mit
dem Argument |wien.dat| aufgerufen wird. Dieses Manko wird durch
Einführung des Pseudozieles |all| erwirkt. Gleichzeitig wird
auch für eine automatische Aufräumung mit dem weiteren Pseudoziel |clean|
gesorgt.

---- verbatim
#       Beschreibungsdatei, Version 2

DB=     /db/vz/VZB1999.gz
RNG=	1996
GRP=    grp=ges,bs.gb,dg.wikl
BL=     bland=ges,dg.bland
BEZ=    bez=ges,dg.wbez
FLAGS=  -e betr=anz -r $(RNG)

all:: betr.md

clean::
        rm -f betr.md

betr.md: $(DB)
        syncnt $(FLAGS) $(DB) $@ $(GRP) $(BL)

all:: wien.md

clean::
        rm -f wien.md

wien.dat: $(DB)
        syncnt $(FLAGS) $(DB) $@ $(GRP) $(BEZ)
----

Beim Aufruf von |make| ohne Argument, oder mit Argument |all|
werden alle Auszählungen generiert. Werden die Auszählungen nicht mehr
benötigt, wird einfach |make clean| aufgerufen und alle generierten
Dateien werden automatisch gelöscht. Die Option |-f| beim
Löschbefehl |rm| unterbindet unnötige Fehlermeldungen,
wenn die Datei bereits gelöscht war.

\margin	Namen der Pseudoziele
Die Namen der Pseudoziele sind an sich beliebig. Sie sollten jedoch nicht
mit existierenden Dateien übereinstimmen. Aus Grunden der Übersichtlichkeit
sollten immer die selben Namen für die gleichen Aufgaben verwendet werden.

Bei Verwendung von Pseudozielen sollte |make| nie mit der Option
|-t| aufgerufen werden, da ansonsten leere Dateien mit dem Namen
der zu aktualisierenden Pseudoziele generiert werden.
Solche Dateien stören die Funktionsweise von |make| und müssen wieder
entfernt werden.

Eine manchmal nützliche Spielerei zeigt die folgende Regel mit dem
Pseudoziel |usage|. Sie muß sinnvollerweise als erste Regel
in der Beschreibungsdatei stehen.

---- verbatim
usage:
        @echo "Aufruf: make all | clean"
----

Wird jetzt |make| ohne Argument aufgerufen, erfolgt die Ausgabe:

----
Aufruf: make all | clean
----
